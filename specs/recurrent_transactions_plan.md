# Recurrent Transactions (Subscriptions) Implementation Plan

This phase focuses on creating the backend infrastructure for managing any type of recurring financial event, such as subscriptions, bills, or recurring income.

## 1. Database Schema Changes (`database.py`)

The database will be updated to store subscription definitions and to enhance the transactions table for forecasting.

*   **Create New `subscriptions` Table:**
    A new table will be created to hold the definitions of all recurring transactions.
    ```sql
    CREATE TABLE subscriptions (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        category TEXT NOT NULL,
        monthly_amount REAL NOT NULL,
        payment_account_id INTEGER NOT NULL,
        start_date DATE NOT NULL,
        end_date DATE,
        is_budget BOOLEAN NOT NULL DEFAULT 0,
        underspend_behavior TEXT NOT NULL DEFAULT 'keep',
        FOREIGN KEY (payment_account_id) REFERENCES accounts (id)
    );
    ```

*   **Alter `transactions` Table:**
    The existing `transactions` table will be modified to support forecasting and link expenses to budgets.
    1.  Rename `budget_category` to `budget`.
    2.  Add a `status` column that can hold either `'committed'` or `'forecast'`.
    3.  The `origin_id` column will be used to group all transactions generated by a single subscription.

## 2. Data Persistence Layer (`repository.py`)

New functions will be added to manage subscription data and their associated forecast transactions.

*   **`add_subscription(conn: Connection, sub: dict)`**: Inserts a new record into the `subscriptions` table.
*   **`get_subscription_by_id(conn: Connection, sub_id: str) -> dict`**: Retrieves a single subscription by its ID.
*   **`get_all_active_subscriptions(conn: Connection, date: date) -> list[dict]`**: Fetches all subscriptions that are active as of a given date.
*   **`delete_future_forecasts(conn: Connection, origin_id: str, from_date: date)`**: Deletes all `'forecast'` status transactions for a given subscription from a specific date onward.
*   **`update_future_forecasts_account(conn: Connection, origin_id: str, from_date: date, new_account_id: int)`**: Updates the account for all future forecasts of a subscription.

## 3. Core Transaction Logic (`transactions.py`)

A new function will be responsible for generating the transaction data for subscriptions.

*   **`create_recurrent_transactions(subscription: dict, account: dict, start_period: date, end_period: date) -> list[dict]`**
    *   **Purpose:** Generates a list of forecast transaction dictionaries for a given subscription over a specified period.
    *   **Logic:**
        1.  Loops through each month from `start_period` to `end_period`.
        2.  For each month, it calls the existing `create_single_transaction` function to generate a complete transaction dictionary.
        3.  It then overrides/sets the following fields on the created transaction:
            *   `status`: Sets to `'forecast'`.
            *   `date_created`: Sets to the date specified in `subscription['start_date']` but for the corresponding month of the loop.
            *   `origin_id`: Sets to `subscription['id']`.
            *   `budget`: Sets to `subscription['id']` if `subscription['is_budget']` is true.

## 4. Main Controller & Scheduler (`main.py`)

A high-level function will orchestrate the generation of all forecasts.

*   **`generate_forecasts(conn: Connection, horizon_months: int)`**
    *   **Purpose:** A scheduler job that creates and maintains forecast transactions up to a defined horizon.
    *   **Logic:**
        1.  Calculates the horizon date (e.g., today + `horizon_months`).
        2.  Fetches all active subscriptions using `repository.get_all_active_subscriptions()`.
        3.  For each subscription, it determines the date range for which new forecasts need to be generated.
        4.  Calls `transactions.create_recurrent_transactions()` to create the transaction data.
        5.  Saves the new forecasts to the database using `repository.add_transactions()`.
